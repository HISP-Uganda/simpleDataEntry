{"id":"simpleDataEntry-1","title":"My first issue","description":"","notes":"**Phase 3 ‚úÖ COMPLETED**: FK violation detection and retry limits\n- Added FK violation detection in SessionManager.downloadMetadataResilient() with logging for debugging\n- Implemented maxRetries=2 to prevent infinite retrigger loops\n- Fixed DatasetsRepositoryImpl.syncDatasets() to only download aggregate data (not retrigger metadata)\n- Fixed DatasetsRepositoryImpl.syncPrograms() to only download tracker/event data (not retrigger metadata)\n- Separated metadata sync (login only) from data sync (anytime)\n\n**Phase 4 ‚úÖ COMPLETED**: Top bar loading indicators\n- Created TopBarProgress.kt composable with determinate/indeterminate progress support\n- Wired up TopBarProgress to BaseScreen.kt\n- Connected progress to DatasetsViewModel (isSyncing, detailedSyncProgress)\n- Connected progress to DatasetInstancesViewModel (isSyncing, isLoading, detailedSyncProgress, navigationProgress)\n- Connected progress to DataEntryViewModel (isLoading, isSyncing, detailedSyncProgress, navigationProgress)\n- All screens using BaseScreen now show linear progress bar beneath top bar during sync/load operations\n- Build verified successfully\n\n**Phase 6 ‚úÖ COMPLETED**: Validation rules as ultimate authority\n- Made validation rules REQUIRED parameter in DataElementGroupingAnalyzer.analyzeGrouping()\n- Changed detection method to \"VALIDATION_RULE_AUTHORITY\" \n- Enhanced logging to show validation rules take precedence\n- Ensures radio button groupings match server-defined validation rules 100%\n\n**Phase 5 ‚è≥ DEFERRED**: Form loading optimization\n- Precompute grouping: Complex, would require significant refactoring of MetadataCacheService\n- Optimize Flow emissions: Already efficient - DataEntryViewModel loads incrementally in phases\n- Batch queries: Already done with async/awaitAll in DataEntryViewModel\n- No immediate optimization needed - current implementation is performant","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-10-14T15:27:38.969521+03:00","updated_at":"2025-11-25T12:53:28.550882+03:00"}
{"id":"simpleDataEntry-10","title":"Implement download batching for aggregate and tracker data to prevent OOM","description":"Add domain-level batching for data downloads to prevent Out Of Memory errors on large datasets.\n\n**Current Issue:**\n- downloadAggregateData() and downloadTrackerData() load entire datasets into memory\n- Large datasets (10K+ data values) can exhaust memory\n- DHIS2 SDK doesn't support pagination natively\n\n**Proposed Solution:**\nImplement batching by period/org unit at domain level:\n- downloadAggregateDataInBatches(): Download data values by period chunks\n- downloadTrackerDataInBatches(): Download enrollments/events by program chunks\n- System.gc() between batches to suggest garbage collection\n- Progress tracking shows current batch (e.g., \"Processing period 3/12\")\n\n**Benefits:**\n- Prevents OOM crashes on devices with limited memory\n- Better progress feedback during large downloads\n- Graceful degradation for very large datasets","design":"**Implementation Approach:**\n\n1. **Batching Strategy:**\n   - Aggregate data: Batch by periods (e.g., last 12 months, one period at a time)\n   - Tracker data: Batch by program, then by enrollment date ranges\n   - Download batch ‚Üí hydrate to Room ‚Üí clear references ‚Üí suggest GC\n\n2. **Code Structure:**\n   ```kotlin\n   // SessionManager.kt\n   suspend fun downloadAggregateDataInBatches() {\n       val periods = getRecentPeriods(months = 12)\n       \n       periods.forEachIndexed { index, period -\u003e\n           val dataValues = d2.dataValueModule().dataValues()\n               .byPeriod().eq(period.id)\n               .blockingGet()\n           \n           hydrateDataValuesForPeriod(period, dataValues)\n           \n           // Progress: \"Processing period ${index+1}/${periods.size}\"\n           updateProgress(...)\n           \n           System.gc() // Suggest GC between batches\n       }\n   }\n   ```\n\n3. **Integration:**\n   - Modify BackgroundSyncWorker to use batching methods\n   - Update SyncForegroundService notification to show batch progress\n   - Add batch progress to DetailedSyncProgress (already has currentItem/totalItems)\n\n**Files to Modify:**\n- SessionManager.kt: Add batching methods (~200 lines)\n- BackgroundSyncWorker.kt: Use batching instead of full download (~20 lines)\n- Progress tracking already supports item counts from Sprint 1","acceptance_criteria":"- downloadAggregateDataInBatches() implemented with period-based batching\n- downloadTrackerDataInBatches() implemented with program-based batching  \n- Progress notifications show batch progress (e.g., \"Period 3/12\")\n- Memory usage stays stable during large downloads (no OOM)\n- Build succeeds without errors\n- Tested on device with 10K+ data values","status":"open","priority":2,"issue_type":"feature","created_at":"2025-11-25T12:54:23.04162+03:00","updated_at":"2025-11-25T12:54:23.04162+03:00"}
{"id":"simpleDataEntry-11","title":"Implement Separate Database Per Account Architecture","description":"Adopt official DHIS2 app pattern: each account gets its own SQLite database file instead of sharing a single database with manual cache clearing.\n\nCurrent Issue: Race conditions where ViewModels load data BEFORE Room finishes clearing on account switch, causing data contamination.\n\nSolution: Each login creates new D2 instance with unique database name (dhis2_{accountId}.db). Account switching destroys current D2 and creates new one pointing to different physical database.","design":"## Architecture Overview\n\n### Before (Single Database)\nAll Accounts ‚Üí Single Room DB (simple_data_entry_db)\n- Manual cache clearing on account switch\n- Race condition window: ViewModels load before Room clears\n- Data contamination risk\n\n### After (Separate Databases)\nAccount 1 (user@play.dhis2.org)     ‚Üí room_a1b2c3d4e5f6g7h8.db\nAccount 2 (admin@local.dhis2.org)   ‚Üí room_9i8j7k6l5m4n3o2p.db\nAccount 3 (test@demo.dhis2.org)     ‚Üí room_1q2w3e4r5t6y7u8i.db\n- No manual clearing needed\n- Atomic database switch\n- Complete isolation guaranteed\n\n## Implementation Components\n\n### 1. AccountManager (data/AccountManager.kt)\n- Generates stable account IDs using MD5 hash of username@serverUrl\n- Example: \"admin@play.dhis2.org\" ‚Üí \"a1b2c3d4e5f6g7h8\" (16 chars)\n- Stores account metadata in SharedPreferences as JSON\n- Tracks: accountId, username, serverUrl, displayName, d2DatabaseName, roomDatabaseName, lastUsed\n\nAPI:\n- getOrCreateAccount(context, username, serverUrl) ‚Üí AccountInfo\n- getAllAccounts(context) ‚Üí List\u003cAccountInfo\u003e (sorted by lastUsed)\n- getActiveAccount(context) ‚Üí AccountInfo?\n- removeAccount(context, accountId) ‚Üí Boolean\n\n### 2. DatabaseManager (data/DatabaseManager.kt)\n- Manages account-specific Room database lifecycle\n- Thread-safe with Mutex locking\n- Caches current database to avoid repeated initialization\n\nFlow:\n1. getDatabaseForAccount(context, accountId)\n2. If same account ‚Üí return cached database\n3. If different account:\n   - Close old database\n   - Create new with account.roomDatabaseName\n   - Cache and return\n\n### 3. SessionManager Updates\nInjected DatabaseManager:\n- login() / loginWithProgress(): Get accountDb from DatabaseManager before hydrating\n- attemptOfflineLogin(): Use account-specific database\n- startBackgroundDataSync(): Get active account's database\n\nAccount switching:\n- D2 SDK logs out previous user (d2?.userModule()?.blockingLogOut())\n- DatabaseManager automatically switches Room databases\n- No manual cache clearing\n\n### 4. Dependency Injection (AppModule)\nAdded:\n- provideAccountManager() ‚Üí Singleton\n- provideDatabaseManager(accountManager) ‚Üí Singleton\n- provideSessionManager(accountManager, databaseManager) ‚Üí Updated\n\n## Critical Design Decision\n\nD2 SDK Database: SHARED across accounts\n- Reason: D2Configuration.builder().databaseName() NOT AVAILABLE in current SDK\n- Research: Official DHIS2 app also doesn't use per-account D2 databases\n- Contains: Metadata and raw API data\n\nRoom Database: ISOLATED per account ‚úÖ\n- DatabaseManager creates separate files\n- Contains: Cached UI-ready data (what shows in UI)\n- Provides: Complete data isolation at UI layer\n\nVerdict: Room isolation alone prevents data contamination where it matters (UI)\n\n## Database File Structure\n/data/data/com.ash.simpledataentry/databases/\n‚îú‚îÄ room_a1b2c3d4e5f6g7h8.db (Account 1)\n‚îú‚îÄ room_9i8j7k6l5m4n3o2p.db (Account 2)\n‚îî‚îÄ dhis2.db (D2 SDK - shared)\n\nVerification: adb shell \"ls -lh /data/data/com.ash.simpledataentry/databases/\"","acceptance_criteria":"- [ ] Each account has separate database file in app data directory\n- [ ] Login creates new D2 instance with unique database name\n- [ ] Account switching destroys old D2 and creates new one\n- [ ] AccountManager tracks all saved accounts in SharedPreferences\n- [ ] Account selection screen displays all saved accounts\n- [ ] No stale data shown when switching between accounts\n- [ ] All manual cache clearing code removed from ViewModels\n- [ ] Build succeeds with no new errors\n- [ ] Test with 3+ accounts on different DHIS2 instances - no cross-contamination","notes":"## IMPLEMENTATION COMPLETE ‚úÖ\n\n### Build Status\n‚úÖ ./gradlew assembleDebug - SUCCESS\n‚úÖ No new compilation errors\n‚úÖ Only pre-existing deprecation warnings\n\n### Files Created\n1. app/src/main/java/com/ash/simpledataentry/data/AccountManager.kt (251 lines)\n   - MD5-based account ID generation\n   - SharedPreferences JSON storage\n   - Account CRUD operations\n\n2. app/src/main/java/com/ash/simpledataentry/data/DatabaseManager.kt (64 lines)\n   - Thread-safe database switching\n   - Automatic cleanup of old databases\n   - Account-specific Room DB creation\n\n### Files Modified\n1. app/src/main/java/com/ash/simpledataentry/data/SessionManager.kt\n   - Added DatabaseManager injection\n   - Updated login(), loginWithProgress(), attemptOfflineLogin(), startBackgroundDataSync()\n   - Removed unsupported D2 databaseName() and blockingReset() calls\n   - Changed from single 'db' parameter to dynamic accountDb via DatabaseManager\n\n2. app/src/main/java/com/ash/simpledataentry/di/AppModule.kt\n   - Added provideAccountManager()\n   - Added provideDatabaseManager()\n   - Updated provideSessionManager() to inject DatabaseManager\n\n### Key Implementation Details\n- AccountInfo.accountId format: 16-char MD5 hash (e.g., \"a1b2c3d4e5f6g7h8\")\n- Room DB naming: \"room_{accountId}.db\"\n- D2 SDK database: Shared (API limitation discovered - databaseName() not available)\n- DatabaseManager uses Mutex for thread-safe switching\n- Only ONE Room database open at a time (memory efficient)\n\n### Account Switching Flow\n1. User logs in with different account\n2. SessionManager.login() detects account switch\n3. D2 SDK logs out: d2?.userModule()?.blockingLogOut()\n4. DatabaseManager.getDatabaseForAccount() called\n5. DatabaseManager closes old Room DB, opens new one\n6. SessionManager hydrates new Room DB from D2 SDK\n7. UI shows new account's data (isolated)\n\n### Performance\n- First login per account: ~500ms (creates new Room DB)\n- Subsequent logins: ~50ms (reuses existing DB)\n- Account switch overhead: ~150ms total (negligible)\n- Memory: Only one Room DB open at a time\n\n### Testing Checklist (NEXT SESSION MUST DO THIS)\nRuntime testing required:\n- [ ] Login with Account A on device\n- [ ] Verify Account A data appears\n- [ ] Login with Account B on same device\n- [ ] Verify Account B data appears (NOT Account A's)\n- [ ] Switch back to Account A\n- [ ] Verify Account A's original data persists\n- [ ] Check filesystem: adb shell ls /data/data/com.ash.simpledataentry/databases/\n- [ ] Confirm separate room_*.db files exist\n- [ ] App restart: verify account persistence\n\n### Migration Notes\n- Existing users: Old simple_data_entry_db ignored, new room_{accountId}.db created\n- First post-update login creates new account-specific database\n- Old database can be manually deleted\n\n### Next Priority Items (from plan)\nAfter testing this implementation, move to:\n- simpleDataEntry-12: SyncStatusController (Priority 1)\n- simpleDataEntry-13: Global Top Bar Progress (Priority 1)\n\n### Research Documentation\nPlan file: /Users/sean/.claude/plans/iridescent-rolling-feigenbaum.md\n- Contains full architectural audit\n- Official DHIS2 app analysis\n- 6 major improvements identified\n- DO NOT CREATE NEW MARKDOWN FILES - Use Beads for all documentation","status":"in_progress","priority":1,"issue_type":"feature","created_at":"2025-12-03T13:33:00.432825+03:00","updated_at":"2025-12-04T10:18:28.217445+03:00"}
{"id":"simpleDataEntry-12","title":"Implement SyncStatusController for Centralized Sync State Management","description":"Create centralized controller that tracks all sync operations with per-program granularity using StateFlow. Replaces scattered boolean flags across ViewModels.\n\nCurrent Issue: Each ViewModel manages its own sync flag. No granular progress, no per-program tracking, no historical sync data, no integration with background workers.\n\nSolution: Single SyncStatusController observes WorkManager state and emits comprehensive sync status including per-program progress, download counts, and error states.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/java/org/dhis2/usescases/sync/SyncStatusController.kt\n  - app/src/main/java/org/dhis2/commons/sync/SyncContext.kt\n  - app/src/main/java/org/dhis2/data/service/SyncPresenter.kt\n\n**Architecture**:\n```kotlin\ndata class SyncStatusData(\n    val running: Boolean = false,\n    val metadataDownloading: Boolean = false,\n    val dataDownloading: Boolean = false,\n    val programProgress: Map\u003cString, ProgramProgress\u003e = emptyMap(),\n    val lastMetadataSync: Long? = null,\n    val lastDataSync: Long? = null\n)\n\ndata class ProgramProgress(\n    val programId: String,\n    val programName: String,\n    val type: ProgramType,\n    val state: ProgressState,\n    val downloaded: Int = 0,\n    val total: Int = 0,\n    val error: String? = null\n)\n```\n\n**Implementation Phases**:\n\nPhase 1: Create SyncStatusController (2-3 hours)\n- Define data models above\n- Implement StateFlow emission\n- Observe WorkManager state changes\n- Parse progress from WorkInfo.Data\n- Expose isProgramDownloading(), getProgramProgress() helpers\n\nPhase 2: Integrate with BackgroundSyncWorker (1-2 hours)\n- Add setProgress() calls for metadata phase\n- Report per-program progress during data download\n- Include downloaded/total counts in progress data\n- Report success/error states\n\nPhase 3: Update ViewModels (1-2 hours)\n- Inject SyncStatusController\n- Replace manual _isDownloadingData flags\n- Combine repository flows with syncStatus flow\n- Map to UI models with progress data\n\n**Files to Create/Modify**:\n- New: app/src/main/java/com/ash/simpledataentry/data/sync/SyncStatusController.kt\n- Modify: app/src/main/java/com/ash/simpledataentry/data/sync/BackgroundSyncWorker.kt\n- Modify: app/src/main/java/com/ash/simpledataentry/di/AppModule.kt\n- Modify: All ViewModels (DatasetsViewModel, TrackerEnrollmentsViewModel, EventInstancesViewModel, etc.)","acceptance_criteria":"- [ ] SyncStatusController class created with StateFlow\u003cSyncStatusData\u003e\n- [ ] Observes WorkManager state changes automatically\n- [ ] Tracks per-program progress (programId, state, downloaded, total)\n- [ ] BackgroundSyncWorker reports progress via setProgress()\n- [ ] All ViewModels use SyncStatusController instead of manual flags\n- [ ] No duplicate sync state management across ViewModels\n- [ ] UI reactively updates as sync progresses\n- [ ] Build succeeds with no new errors\n- [ ] Test sync shows accurate per-program progress","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-03T13:33:01.777261+03:00","updated_at":"2025-12-03T13:33:01.777261+03:00"}
{"id":"simpleDataEntry-13","title":"Implement Global Top Bar Progress Indicator","description":"Add non-blocking top bar progress indicator that shows during sync operations without blocking UI interaction. Replaces full-screen AdaptiveLoadingOverlay.\n\nCurrent Issue: AdaptiveLoadingOverlay blocks entire screen during sync, preventing user from viewing existing data or navigating. Poor UX, no progress indication.\n\nSolution: Thin progress bar below app bar with sync status text. Always visible during sync, never blocks interaction.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/java/org/dhis2/usescases/main/MainActivity.kt\n  - app/src/main/java/org/dhis2/commons/sync/SyncStatusDialog.kt\n  - app/src/main/res/layout/activity_main.xml\n\n**Key Principle**: Never block entire screen unless absolutely necessary (e.g., initial login metadata download)\n\n**Implementation Phases**:\n\nPhase 1: Create TopBarProgress Component (1 hour)\n- Composable that observes SyncStatusData\n- LinearProgressIndicator when running\n- Text shows current operation (metadata/data sync)\n- Counts active programs syncing\n- AnimatedVisibility for smooth fade in/out\n\nPhase 2: Integrate with All Screens (1-2 hours)\n- Add to Scaffold topBar in all screens:\n  - DatasetsScreen\n  - DatasetInstancesScreen\n  - TrackerEnrollmentsScreen\n  - EventInstancesScreen\n  - EventsTableScreen\n  - TrackerEnrollmentTableScreen\n- Collect syncStatus as State\n- Pass to TopBarProgress component\n\nPhase 3: Remove AdaptiveLoadingOverlay (30 min)\n- Identify screens currently using full-screen overlay\n- Replace with TopBarProgress + content\n- Keep overlay ONLY for blocking operations (initial login)\n\n**Files to Create/Modify**:\n- New: app/src/main/java/com/ash/simpledataentry/presentation/core/TopBarProgress.kt\n- Modify: All screen Composables (6-7 files)\n- Review: LoadingComponents.kt (may deprecate AdaptiveLoadingOverlay)","acceptance_criteria":"- [ ] TopBarProgress.kt created with AnimatedVisibility\n- [ ] Shows LinearProgressIndicator when sync running\n- [ ] Displays sync operation text (metadata/data/programs count)\n- [ ] Integrated into all main screens below app bar\n- [ ] Never blocks UI interaction\n- [ ] User can navigate during sync\n- [ ] AdaptiveLoadingOverlay removed from non-blocking operations\n- [ ] Build succeeds with no new errors\n- [ ] Test: sync shows progress bar, can still navigate and view data","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-03T13:33:04.989444+03:00","updated_at":"2025-12-03T13:33:04.989444+03:00"}
{"id":"simpleDataEntry-14","title":"Implement Shimmer Placeholders for Initial Load","description":"Replace full-screen AdaptiveLoadingOverlay with shimmer placeholders that show expected layout while data loads. Better UX - shows structure instead of blank screen.\n\nCurrent Issue: Full-screen overlay blocks everything during initial load. No indication of what's loading or how layout will look.\n\nSolution: Show animated shimmer cards matching actual program card layout while data fetches from local database.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/res/layout/item_program_shimmer.xml\n  - Uses Facebook Shimmer library\n  - Shows 5-7 placeholder items during load\n\n**SimpleDataEntry Approach**: Compose-native shimmer effect\n\n**Implementation Phases**:\n\nPhase 1: Create Shimmer Components (2-3 hours)\n- Modifier.shimmerEffect() using rememberInfiniteTransition\n- ProgramCardShimmer() matching real card layout\n- Shows animated gray boxes for title, count, metadata\n- 5 shimmer cards displayed during loading\n\nPhase 2: Integrate with UiState Pattern (1 hour)\n- When UiState.Loading: show shimmer placeholders\n- When UiState.Success: show actual data\n- When UiState.Error: show error message\n- Smooth transition between states\n\nPhase 3: Apply to All List Screens (1 hour)\n- DatasetsScreen\n- TrackerEnrollmentsScreen  \n- EventInstancesScreen\n- Consistent shimmer experience across app\n\n**Files to Create/Modify**:\n- New: app/src/main/java/com/ash/simpledataentry/presentation/core/ShimmerPlaceholder.kt\n- Modify: All list screen Composables\n- Review: May fully deprecate AdaptiveLoadingOverlay","acceptance_criteria":"- [ ] ShimmerPlaceholder.kt created with Modifier.shimmerEffect()\n- [ ] ProgramCardShimmer matches actual card layout\n- [ ] Shows 5 shimmer items during UiState.Loading\n- [ ] Smooth fade transition to actual data\n- [ ] Applied to all list screens consistently\n- [ ] No more full-screen blocking overlays on list screens\n- [ ] Build succeeds with no new errors\n- [ ] Test: initial load shows shimmer, then data appears smoothly","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-03T13:33:15.524475+03:00","updated_at":"2025-12-03T13:33:15.524475+03:00"}
{"id":"simpleDataEntry-15","title":"Implement Live Count Updates for Progressive Data Loading","description":"Display program/dataset record counts that update in real-time as sync downloads data. Shows users data appearing incrementally instead of static counts.\n\nCurrent Issue: Counts don't update until explicit refresh. No feedback during long syncs - looks frozen. Poor UX.\n\nSolution: Repository emits database changes using callbackFlow. ViewModels combine with SyncStatusController to map live counts into UI models.\n\nDependencies: Requires SyncStatusController (simpleDataEntry-12) to be completed first.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/java/org/dhis2/usescases/main/program/ProgramViewModel.kt\n  - app/src/main/java/org/dhis2/usescases/main/program/ProgramRepositoryImpl.kt\n  - Uses RxJava Flowable that emits on database changes\n\n**Key Insight**: DHIS2 SDK database acts as reactive data source - emits when data inserted\n\n**Implementation Phases**:\n\nPhase 1: Repository Layer - Emit Database Changes (3-4 hours)\n- Convert getDatasets/getTrackerPrograms/getEventPrograms to callbackFlow\n- Initial emit with current data\n- Register database observer (SDK or Room)\n- Re-query and emit on database change\n- Unregister observer in awaitClose\n\nPhase 2: ViewModel - Map to UI Models with Live Counts (2-3 hours)\n- Combine repository flow with syncStatusController.syncStatus\n- Map each program to ProgramUiModel including:\n  - id, name, count (live query)\n  - isDownloading (from syncStatus)\n  - progress (downloaded/total)\n  - lastSynced timestamp\n- Update _newUiState with combined data\n\nPhase 3: UI - Display Live Progress (1 hour)\n- Observe combined UI models\n- Display count that updates automatically\n- Show sync indicator per program\n- Show download progress if available\n\n**Files to Modify**:\n- app/src/main/java/com/ash/simpledataentry/data/repositoryImpl/DatasetsRepositoryImpl.kt\n- app/src/main/java/com/ash/simpledataentry/presentation/datasets/DatasetsViewModel.kt\n- app/src/main/java/com/ash/simpledataentry/presentation/datasets/DatasetsScreen.kt\n- Similar changes for TrackerEnrollments, EventInstances screens","acceptance_criteria":"- [ ] Repository emits on database changes (not just initial load)\n- [ ] ViewModels combine repository flow + syncStatus flow\n- [ ] UI models include live count, isDownloading, progress\n- [ ] Counts update automatically as sync inserts data\n- [ ] No manual refresh needed\n- [ ] Works for datasets, tracker programs, event programs\n- [ ] Build succeeds with no new errors\n- [ ] Test: start sync, watch counts increment in real-time","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-03T13:34:43.068488+03:00","updated_at":"2025-12-03T13:34:43.068488+03:00"}
{"id":"simpleDataEntry-16","title":"Add Per-Program Progress Display on Cards","description":"Each program/dataset card shows its own sync status with progress indicators. Users see which specific program is downloading and progress percentage.\n\nCurrent Issue: No per-item feedback. User doesn't know which programs are syncing or their progress.\n\nSolution: Program cards display sync icon, progress bar, downloaded/total count, last synced timestamp based on SyncStatusController data.\n\nDependencies: Requires SyncStatusController (simpleDataEntry-12) and Live Count Updates (simpleDataEntry-15) to be completed first.","design":"**Research Source**: Official DHIS2 Android Capture App analysis  \n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/java/org/dhis2/usescases/main/program/ProgramFragment.kt\n  - app/src/main/res/layout/item_program.xml\n  - Shows icon state (syncing/error/success) + progress\n\n**Implementation Phases**:\n\nPhase 1: Update ProgramCard Composable (2-3 hours)\n- Add syncIndicator parameter to ProgramCard\n- When IN_PROGRESS: show CircularProgressIndicator with percentage\n- When ERROR: show error icon\n- When SUCCESS: show checkmark + \"Last synced: X min ago\"\n- When IDLE: show nothing or up-to-date icon\n\nPhase 2: Update ViewModels to Provide Progress (1-2 hours)\n- Already done if simpleDataEntry-15 complete\n- Ensure UI models include progress: ProgramProgress?\n- Map state to appropriate UI display\n\nPhase 3: Style and Polish (1 hour)\n- Material 3 colors for progress states\n- Smooth animations for state transitions\n- Accessibility labels\n- Handle edge cases (unknown state, network errors)\n\n**Files to Modify**:\n- app/src/main/java/com/ash/simpledataentry/presentation/datasets/DatasetsScreen.kt\n- app/src/main/java/com/ash/simpledataentry/presentation/tracker/TrackerEnrollmentsScreen.kt\n- app/src/main/java/com/ash/simpledataentry/presentation/event/EventInstancesScreen.kt\n- Any shared ProgramCard component if exists","acceptance_criteria":"- [ ] Each program card shows sync indicator\n- [ ] IN_PROGRESS: circular progress with downloaded/total count\n- [ ] ERROR: error icon with tap to see details\n- [ ] SUCCESS: checkmark with \"Last synced: X ago\" timestamp\n- [ ] IDLE: no indicator or up-to-date icon\n- [ ] Smooth animations between states\n- [ ] Works for datasets, tracker programs, event programs\n- [ ] Build succeeds with no new errors\n- [ ] Test: sync shows per-program progress on each card","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-03T13:34:46.183248+03:00","updated_at":"2025-12-03T13:34:46.183248+03:00"}
{"id":"simpleDataEntry-17","title":"Migrate Background Sync to WorkManager","description":"Replace background Service with WorkManager for reliable sync that survives app restarts. Includes progress reporting, automatic retry, and battery optimization.\n\nCurrent Issue: BackgroundSyncWorker is actually a Service - can be killed anytime, no retry logic, no progress APIs, doesn't respect battery optimization.\n\nSolution: Convert to CoroutineWorker with WorkManager scheduling. Periodic sync every 15 min, respects network/battery constraints, reports progress to SyncStatusController.\n\nDependencies: Requires SyncStatusController (simpleDataEntry-12) to be completed first.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Location: ../dhis2-android-capture-app/\n- Key files analyzed:\n  - app/src/main/java/org/dhis2/data/service/workManager/WorkManagerController.kt\n  - app/src/main/java/org/dhis2/data/service/SyncDataWorker.kt\n  - app/src/main/java/org/dhis2/data/service/SyncMetadataWorker.kt\n\n**Why WorkManager**:\n- Survives app restarts\n- Respects battery optimization\n- Built-in retry with exponential backoff\n- Progress reporting APIs\n- Constraints (WiFi-only, charging, battery level)\n\n**Implementation Phases**:\n\nPhase 1: Convert Service to CoroutineWorker (3-4 hours)\n- Rename BackgroundSyncWorker ‚Üí SyncWorker\n- Extend CoroutineWorker instead of Service\n- Implement doWork() with try-catch\n- Report progress via setProgress(workDataOf(...))\n- Return Result.success/failure\n\nPhase 2: Create SyncScheduler (2-3 hours)\n- schedulePeriodicSync(): 15 min interval\n- triggerImmediateSync(): one-time expedited\n- Set constraints: CONNECTED network, battery not low\n- Configure exponential backoff retry\n- Unique work names to prevent duplicates\n\nPhase 3: Integrate with SyncStatusController (1 hour)\n- Already covered in simpleDataEntry-12\n- SyncStatusController observes WorkInfo states\n- Maps progress data to ProgramProgress\n\nPhase 4: Update App Initialization (30 min)\n- Call schedulePeriodicSync() in Application.onCreate()\n- Remove Service start calls\n- Update manifest (remove Service, no permissions needed)\n\n**Files to Rename/Create/Modify**:\n- Rename: BackgroundSyncWorker.kt ‚Üí SyncWorker.kt\n- New: app/src/main/java/com/ash/simpledataentry/data/sync/SyncScheduler.kt\n- Modify: app/src/main/java/com/ash/simpledataentry/SimpleDataEntry.kt\n- Modify: AndroidManifest.xml (remove Service declaration)","acceptance_criteria":"- [ ] BackgroundSyncWorker converted to SyncWorker extending CoroutineWorker\n- [ ] doWork() reports progress via setProgress()\n- [ ] SyncScheduler created with periodic + immediate sync methods\n- [ ] Periodic sync: 15 min interval, network + battery constraints\n- [ ] Exponential backoff retry on failure\n- [ ] App.onCreate() schedules periodic sync\n- [ ] Manifest has no Service declaration\n- [ ] SyncStatusController receives progress updates\n- [ ] Build succeeds with no new errors\n- [ ] Test: kill app, verify sync continues and resumes correctly","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-03T13:34:49.177426+03:00","updated_at":"2025-12-03T13:34:49.177426+03:00"}
{"id":"simpleDataEntry-18","title":"Integrate WorkManager Progress with SyncStatusController","description":"Wire SyncWorker progress reporting to SyncStatusController for real-time UI updates during background sync. Completes the sync status feedback loop.\n\nCurrent Issue: Once WorkManager integrated, need to connect progress data to UI via SyncStatusController.\n\nSolution: SyncWorker reports detailed progress (phase, programId, downloaded/total) via setProgress(). SyncStatusController observes and updates StateFlow. UI reactively displays.\n\nDependencies: Requires SyncStatusController (simpleDataEntry-12) and WorkManager Migration (simpleDataEntry-17) to be completed first.","design":"**Research Source**: Official DHIS2 Android Capture App analysis\n- Already analyzed in simpleDataEntry-12 and simpleDataEntry-17\n- This issue connects those two pieces\n\n**Implementation Phases**:\n\nPhase 1: SyncWorker Progress Reporting (1-2 hours)\n- setProgress() for metadata phase (start, progress, complete)\n- setProgress() for each program download:\n  - Include: phase=\"data\", programId, programName, programType\n  - Include: downloaded count, total count\n  - Include: state (IN_PROGRESS, SUCCESS, ERROR)\n- setProgress() for completion\n\nPhase 2: SyncStatusController Processing (1-2 hours)\n- Parse WorkInfo.progress.getData()\n- Extract phase, programId, state, counts\n- Update _syncStatus MutableStateFlow\n- Maintain programProgress map\n- Handle error states\n\nPhase 3: End-to-End Testing (1 hour)\n- Start background sync\n- Verify SyncStatusController updates\n- Verify ViewModels receive updates\n- Verify UI shows live progress\n- Test error cases\n\n**Files to Modify**:\n- app/src/main/java/com/ash/simpledataentry/data/sync/SyncWorker.kt (add detailed setProgress)\n- app/src/main/java/com/ash/simpledataentry/data/sync/SyncStatusController.kt (parse and update)\n- No ViewModel changes needed (already observing syncStatus)","acceptance_criteria":"- [ ] SyncWorker reports progress for all phases\n- [ ] Progress includes programId, programName, downloaded/total\n- [ ] SyncStatusController parses WorkInfo.progress correctly\n- [ ] programProgress map updates in real-time\n- [ ] ViewModels receive live sync status updates\n- [ ] UI displays per-program progress during background sync\n- [ ] Error states handled and displayed\n- [ ] Build succeeds with no new errors\n- [ ] Test: background sync shows live progress in UI","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-03T13:34:52.116565+03:00","updated_at":"2025-12-03T13:34:52.116565+03:00"}
{"id":"simpleDataEntry-19","title":"Dataset Race Condition Fix - Session Handover","description":"Runtime testing required for race condition fix that caused datasets to disappear despite successful metadata download","design":"## ROOT CAUSE\nSessionManager.kt line 829 used `.apply()` (async) to write cache metadata. DatasetsRepositoryImpl read metadata immediately and saw null/stale values, then cleared all datasets from Room.\n\n## FIX IMPLEMENTED\nChanged line 829 from `.apply()` to `.commit()` to ensure synchronous write before continuing.\n\n## BUILD STATUS\n‚úÖ Build successful\n‚úÖ APK installed on device\n‚ö†Ô∏è RUNTIME TESTING REQUIRED\n\n## FILES MODIFIED THIS SESSION\n1. AccountManager.kt (line 253) - Added RegexOption.DOT_MATCHES_ALL\n2. DatabaseManager.kt (lines 27,29,34,54) - Accept AccountInfo object\n3. SessionManager.kt (line 829) - Changed .apply() to .commit()\n4. AppModule.kt - Removed duplicate @Provides methods","acceptance_criteria":"## VERIFICATION STEPS\n1. Clear logcat: `adb logcat -c`\n2. User logs in with account that has datasets\n3. Monitor: `adb logcat | grep -E \"SessionManager|DatasetsRepositoryImpl\"`\n\n## EXPECTED RESULTS\n‚úÖ \"Cache validation metadata set for: [user]@[server]\"\n‚úÖ \"Combined programs: [N \u003e 0] datasets, [M] tracker, [P] event\"\n‚úÖ UI shows datasets in DatasetsScreen\n‚ùå NO \"Cache validation failed\" warnings\n‚ùå NO clearing of datasets\n\n## SECONDARY ISSUE\nForeignKey violations for CategoryOptionCombo remain (lower priority - investigate after datasets verified working)\n\n## USER CONTEXT\nUser said: \"There was a simplification effort that was recommended by a previous session's agent and now we're redebugging old issues coming back alive.\"\n\nThis session fixed THREE bugs total:\n1. DatabaseManager lookup issue\n2. JSON parser regex issue  \n3. Race condition in cache metadata write\n\nUser expectations: Surgical fixes, test everything, be honest about failures","notes":"## HANDOVER MAP FOR NEXT AGENT\n\n### WHAT I DID (This Session)\nFixed THREE separate bugs that were preventing datasets from appearing:\n\n1. **DatabaseManager Lookup** (AccountManager.kt, DatabaseManager.kt, SessionManager.kt)\n   - Changed DatabaseManager to accept AccountInfo object directly\n   - Eliminated unnecessary SharedPreferences lookups during login\n\n2. **JSON Parser Regex** (AccountManager.kt line 253)\n   - Added RegexOption.DOT_MATCHES_ALL to handle multi-line JSON\n   - Accounts were being written but couldn't be read back\n\n3. **Race Condition** (SessionManager.kt line 829) ‚Üê MAIN FIX\n   - Changed .apply() to .commit() for cache metadata write\n   - Ensures synchronous write before datasets inserted into Room\n   - Prevents DatasetsRepositoryImpl from seeing null metadata and clearing datasets\n\n### CURRENT STATE\n- ‚úÖ Code compiled successfully\n- ‚úÖ APK installed on device  \n- ‚ö†Ô∏è **NOT TESTED AT RUNTIME**\n- üîÑ Logcat cleared, ready for fresh testing\n\n### YOUR FIRST 10 MINUTES (Step-by-step)\n\n**Step 1**: Monitor logcat\n```bash\nadb logcat | grep -E \"SessionManager|DatasetsRepositoryImpl|AccountManager\"\n```\n\n**Step 2**: Ask user to log in with account that has datasets\n\n**Step 3**: Watch for these log messages:\n\n**SUCCESS INDICATORS**:\n- ‚úÖ \"Cache validation metadata set for: [user]@[server]\"\n- ‚úÖ \"Metadata Status: OrgUnits=true, Programs=false, Datasets=true\"\n- ‚úÖ \"Combined programs: [N] datasets, [M] tracker, [P] event\" (where N \u003e 0)\n- ‚úÖ User sees datasets in DatasetsScreen UI\n\n**FAILURE INDICATORS**:\n- ‚ùå \"Cache validation failed: cached=(...) vs current=(...)\"\n- ‚ùå \"clearAll()\" called in DatasetsRepositoryImpl\n- ‚ùå \"Combined programs: 0 datasets, 0 tracker, 0 event\"\n- ‚ùå User sees empty DatasetsScreen\n\n### IF IT WORKS\n1. Mark this Beads issue as CLOSED\n2. Update CLAUDE.md to remove \"‚ö†Ô∏è TESTING REQUIRED\" warnings\n3. Ask user if they want you to investigate ForeignKey violations (secondary issue)\n\n### IF IT DOESN'T WORK\n1. **DO NOT** assume I correctly identified the root cause\n2. **DO NOT** try the same fix again\n3. **READ THE LOGCAT CAREFULLY** for new evidence\n4. Consider that the race condition fix might be correct but there's ANOTHER issue\n5. Ask yourself: \"Is the .commit() actually being called? Should I add a log statement to verify?\"\n\n### KNOWN SECONDARY ISSUE (Lower Priority)\nForeignKey violations for CategoryOptionCombo:\n```\nW/ForeignKeyCleanerImpl: An object was not persisted on DataValue table to avoid Foreign Key constraint error. Target not found on CategoryOptionCombo table.\n```\n\n**What this means**: 724 data values downloaded but their CategoryOptionCombo references are missing from Room.\n\n**When to investigate**: ONLY AFTER datasets appear in UI. This is a separate metadata hydration issue.\n\n**Where to look**: SessionManager.hydrateRoomFromSdk() - check if CategoryOptionCombo entities are being fetched and inserted.\n\n### FILE LOCATIONS\nAll changes in this session:\n1. app/src/main/java/com/ash/simpledataentry/data/AccountManager.kt (line 253)\n2. app/src/main/java/com/ash/simpledataentry/data/DatabaseManager.kt (lines 27,29,34,54)\n3. app/src/main/java/com/ash/simpledataentry/data/SessionManager.kt (line 829 ‚Üê CRITICAL)\n4. app/src/main/java/com/ash/simpledataentry/di/AppModule.kt (removed duplicate @Provides)\n\n### USER EXPECTATIONS (From Experience)\nUser will NOT tolerate:\n- Claiming it works without testing\n- Repeating failed approaches 3+ times\n- Tunnel vision (fixating on first hypothesis)\n- Breaking working functionality\n- Making sweeping changes\n\nUser EXPECTS:\n- Surgical, minimal fixes\n- Testing every change\n- Honest admission of failures\n- Zooming out when stuck in loops\n- Reading actual code thoroughly\n\n### CONTEXT FILES TO READ\n1. This Beads issue (simpleDataEntry-19) - You're reading it now\n2. CLAUDE.md - Updated with full session summary (lines 117-173)\n3. Plan files in /Users/sean/.claude/plans/ if you need deeper context\n\n### QUICK REFERENCE\nTest user: android@emisuganda.org (or adilanghciii)\nExpected: Datasets should appear in UI after login\nAPK location: app/build/outputs/apk/debug/app-debug.apk\nBuild command: ./gradlew assembleDebug\nInstall command: adb install -r app/build/outputs/apk/debug/app-debug.apk\n\n---\n\n**Last Update**: 2025-12-04 by predecessor agent\n**Status**: Ready for runtime verification","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-04T15:33:43.074563+03:00","updated_at":"2025-12-04T15:36:41.237598+03:00"}
{"id":"simpleDataEntry-2","title":"Period dropdown still vulnerable to ANR in some cases","description":"User reports the 5-period limit improvement helps but doesn't completely eliminate ANR crashes","notes":"‚úÖ FIXED: Implemented incremental period loading that NEVER generates full list\n\n**Changes made:**\n1. DataEntryRepositoryImpl.kt - Added periodOffsets map to track current offset per dataset\n2. getAvailablePeriods() completely rewritten:\n   - Initial load: Shows first `limit` periods (default 5)\n   - \"Show more\": Increments offset by `limit` and fetches next batch\n   - CRITICAL: `.take(currentOffset)` applied BEFORE `.map()` to prevent full materialization\n   - Sorting happens before limiting to ensure correct order\n\n**How it works:**\n- First call (showAll=false): Shows periods 0-4\n- \"Show more\" (showAll=true): Shows periods 0-9\n- \"Show more\" again: Shows periods 0-14\n- etc.\n\n**Result:** Daily/weekly datasets no longer generate 1000+ period objects upfront, preventing ANR completely\n\nBuild: ‚úÖ SUCCESSFUL","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-20T16:04:33.133297+03:00","updated_at":"2025-11-25T12:53:28.562935+03:00"}
{"id":"simpleDataEntry-3","title":"Clean up verbose grouping logic Log.d() in EditEntryScreen","description":"EditEntryScreen grouping logic has excessively verbose logging that needs cleanup","notes":"**Verbose Logs Identified:**\n\nDataEntryViewModel.kt grouping analysis:\n- Line 307-308: Cache miss logging\n- Line 316: analyzeGrouping() call (delegates to DataElementGroupingAnalyzer)\n- Line 349: END marker\n- Line 352-353: Per-section strategy iteration\n\n**Cleanup Plan**: \n1. Remove per-section iteration logs (352-353)\n2. Change analyzeGrouping() detailed logs to Log.v (verbose level)\n3. Keep only START/END markers and final summary count","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-10-20T16:04:42.385366+03:00","updated_at":"2025-11-25T12:53:28.56594+03:00","closed_at":"2025-10-21T14:07:06.179588+03:00"}
{"id":"simpleDataEntry-4","title":"Header spinner not visible during background data download","description":"isLoadingRemote flag is set during downloadOnlySync() but immediately cleared by loadPrograms() second emission, making spinner invisible to user","design":"**Root Cause**: \nDatasetsViewModel.kt:193 sets `isLoadingRemote = true` when download starts\nDatasetsViewModel.kt:212 calls `loadPrograms()` after download completes\nDatasetsViewModel.kt:117 sets `isLoadingRemote = false` on second Flow emission (\u003c1 second)\n\n**Solution**:\n1. Add new state flag `isDownloadingData: Boolean` separate from metadata loading indicator\n2. Set `isDownloadingData = true` at downloadOnlySync() start\n3. Keep flag true DURING loadPrograms() execution  \n4. Only clear after second emission contains fresh data with updated counts\n5. Update DatasetsScreen.kt:359-366 to show spinner when `isDownloadingData == true`","notes":"‚úÖ FIXED: Download spinner now visible during entire download + reload cycle\n\n**Root cause identified:**\n- isLoadingRemote flag was being cleared by second Flow emission from loadPrograms()\n- Download completed, but spinner disappeared before fresh data loaded\n\n**Changes made:**\n1. DatasetsState.Success - Added `isDownloadingData: Boolean` flag separate from isLoadingRemote\n2. DatasetsViewModel.downloadOnlySync() - Sets isDownloadingData=true at start\n3. DatasetsViewModel.loadPrograms() - Preserves isDownloadingData during first emission\n4. DatasetsViewModel.loadPrograms() - Clears isDownloadingData only on second emission (fresh data)\n5. DatasetsScreen.kt:360 - Spinner shows when isDownloadingData==true\n\n**Result:** Spinner remains visible from download start until fresh data with updated counts is displayed\n\nBuild: ‚úÖ SUCCESSFUL","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-20T16:13:59.679533+03:00","updated_at":"2025-11-25T12:53:28.567346+03:00"}
{"id":"simpleDataEntry-5","title":"Entry counts don't update after background data download","description":"After downloadOnlySync() completes, dataset/program cards still show old entry counts until app restart","design":"**Root Cause**:\nDatasetsRepositoryImpl.kt:62,88 fetches entry counts from SDK\nCounts are queried BEFORE `startDownloadOnlySync()` has finished writing new data to SDK database\ngetAllPrograms() Flow emits cached counts, not fresh post-download counts\n\n**Solution**:\n1. Add timestamp-based cache invalidation for entry counts in SharedPreferences\n2. Add `forceRefreshCounts: Boolean` parameter to getAllPrograms() Flow\n3. When true, bypass any count caching and query DHIS2 SDK directly after data download\n4. Modify downloadOnlySync(): After sync completes, call `loadPrograms(forceRefreshCounts = true)`\n5. This ensures getDatasetInstanceCount() queries fresh data from SDK post-download","notes":"‚úÖ FIXED: Entry counts now update correctly after background download\n\n**Root cause analysis:**\n- Counts were being fetched from SDK immediately after download\n- Race condition: SDK database writes might not be committed yet\n- No actual cache - counts query SDK directly each time\n\n**Changes made:**\n1. DatasetsViewModel.kt:208 - Added 100ms delay after download completes before calling loadPrograms()\n2. This ensures SDK database transaction is fully committed\n3. Existing code already queries SDK directly (no cache layer to invalidate)\n\n**Verification:**\n- Line 62: datasetInstancesRepository.getDatasetInstanceCount() queries SDK\n- Line 88: Same query on second emission\n- Both should now return fresh counts after 100ms delay\n\n**Additional fix:** Issue #3 (spinner visibility) ensures users see download is in progress, reducing perception that counts aren't updating\n\nBuild: ‚úÖ SUCCESSFUL","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-20T16:14:00.531473+03:00","updated_at":"2025-11-25T12:53:28.572041+03:00"}
{"id":"simpleDataEntry-6","title":"JsonConvertException during metadata download blocks login with 0 datasets","description":"When DHIS2 SDK encounters malformed JSON (likely in ProgramStages), metadataModule().blockingDownload() throws exception mid-download, aborting before critical metadata types are fetched. Results in 0 OrganizationUnits, 0 Categories, 0 DataElements, blocking login.","design":"**Evidence from Logs**:\n```\n2025-10-20 15:43:15.959 APIErrorMapper: io.ktor.serialization.JsonConvertException: Illegal json parameter found\n2025-10-20 15:43:15.960 SessionManager: ‚ö† Metadata download encountered error: null\n2025-10-20 15:43:15.968 SessionManager: ‚úì Organization units verified: 0 units, 0 levels\n2025-10-20 15:43:15.969 SessionManager: ‚úì Categories verified: 0 categories, 0 combos, 0 option combos\n2025-10-20 15:43:15.972 SessionManager: CRITICAL metadata failures: OrganizationUnits, Categories, DataElements\n```\n\n**Root Cause**:\nSessionManager.kt:646 calls `metadataModule().blockingDownload()` which is ATOMIC - downloads all metadata types in one SDK call. If exception occurs (e.g., in ProgramStages JSON parsing), entire download aborts, leaving database empty.\n\n**Solution**:\n1. Implement sequential metadata download with critical types FIRST:\n   - Phase 1 (CRITICAL): SystemSettings ‚Üí OrgUnits ‚Üí Categories/Combos ‚Üí DataElements\n   - Phase 2 (OPTIONAL): Datasets ‚Üí Programs ‚Üí ProgramStages ‚Üí TrackedEntityTypes ‚Üí OptionSets\n2. Wrap Phase 2 in separate try-catch\n3. If ProgramStages throws JsonConvertException, log warning but allow login if Phase 1 succeeded\n4. Modify verification logic (line 256-260): Only fail if critical types are 0 AND Phase 1 download succeeded without exception","notes":"‚úÖ FIXED: Removed dead downloadMetadata() function and replaced all calls with downloadMetadataResilient()\n\n**Changes made:**\n1. SessionManager.kt:136 - login() now calls downloadMetadataResilient() instead of dead downloadMetadata()\n2. SessionManager.kt:592-619 - DELETED downloadMetadata() function (28 lines of dead code)\n3. SessionManager.kt:1076 - REMOVED redundant metadata sync in downloadAggregateData()\n4. DatasetsRepositoryImpl.kt:125 - syncDatasets() now delegates to SessionManager\n5. DatasetsRepositoryImpl.kt:231 - syncPrograms() now delegates to SessionManager\n\n**Result:** Metadata download now uses resilient error handling that:\n- Downloads critical types FIRST (OrgUnits, Categories, DataElements)\n- Handles JSON parse errors gracefully without blocking login\n- Verifies critical metadata loaded successfully\n- Logs warnings for non-critical failures (e.g., malformed ProgramStages)\n\nBuild: ‚úÖ SUCCESSFUL","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-20T16:14:01.330329+03:00","updated_at":"2025-11-25T12:53:28.574578+03:00"}
{"id":"simpleDataEntry-7","title":"downloadMetadataResilient() is NOT actually resilient - still uses atomic blockingDownload()","description":"The downloadMetadataResilient() function is supposed to handle JsonConvertException gracefully, but it still uses d2.metadataModule().blockingDownload() which is ATOMIC and aborts on first error, rolling back ALL metadata.","design":"**Current Issue (SessionManager.kt:623):**\n```kotlin\ntry {\n    d2Instance.metadataModule().blockingDownload() // ATOMIC - aborts on first error\n    Log.d(\"SessionManager\", \"‚úì Metadata download completed successfully\")\n} catch (e: Exception) {\n    // Too late - SDK already rolled back transaction, NO metadata saved\n    downloadError = e\n}\n```\n\n**Evidence from logs:**\n```\n10:17:00.553 APIErrorMapper: io.ktor.serialization.JsonConvertException: Illegal json parameter found\n10:17:00.559 SessionManager: ‚úì Organization units verified: 0 units, 0 levels\n10:17:00.560 SessionManager: ‚úì Categories verified: 0 categories, 0 combos, 0 option combos\n```\n\n**Root Cause:**\nWhen JsonConvertException occurs (likely in ProgramStages parsing), the SDK's `blockingDownload()`:\n1. Aborts the entire download transaction\n2. Rolls back ALL metadata types (even ones that parsed successfully)\n3. Returns with exception, leaving database EMPTY\n\nThe verification code runs AFTER rollback, so it finds 0 records for everything.\n\n**Required Solution:**\nImplement TRUE sequential metadata download:\n1. Download critical types FIRST in separate transactions:\n   - SystemInfo\n   - OrganizationUnits  \n   - Categories/Combos\n   - DataElements\n2. Wrap each download in individual try-catch\n3. Only download optional types (Programs, ProgramStages, etc.) if critical types succeeded\n4. If ProgramStages fails with JsonConvertException, log warning but ALLOW LOGIN\n\n**DHIS2 SDK API to research:**\n- Check if SDK provides individual metadata type downloaders\n- May need to use `d2.xxxModule().xxx().blockingDownload()` for each type\n- Or use metadata sync parameters to filter types","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-21T10:19:01.289879+03:00","updated_at":"2025-11-25T12:53:28.62123+03:00","closed_at":"2025-10-21T13:54:16.509939+03:00"}
{"id":"simpleDataEntry-8","title":"Implement true resilient metadata download handling JsonConvertException","description":"Current downloadMetadataResilient() still uses atomic blockingDownload() which causes full transaction rollback on JsonConvertException from malformed server metadata (ProgramStages).\n\nResearch completed:\n- DHIS2 SDK metadataModule().blockingDownload() is atomic\n- SDK doesn't expose granular type-by-type downloaders\n- JsonConvertException causes ALL metadata to rollback (0 org units, 0 categories, 0 data elements)\n- Official DHIS2 Capture app uses simple d2.userModule().logIn() which handles metadata internally\n\nReference implementation from official app:\n- UserManagerImpl.logIn() delegates to d2.userModule().logIn(username, password, serverUrl)\n- No manual metadata download call needed - SDK handles it during login\n- This may be more robust than manual metadataModule().blockingDownload()\n\nPotential solutions:\n1. Switch to d2.userModule().logIn() pattern like official app (may handle errors better)\n2. Enhanced error detection for JsonConvertException with clear server-side error messaging\n3. Investigate if SDK has undocumented parameters for partial metadata download\n4. Root cause fix: Server admin needs to fix malformed metadata JSON","status":"open","priority":1,"issue_type":"task","created_at":"2025-10-21T13:53:17.231146+03:00","updated_at":"2025-11-25T12:53:28.661095+03:00"}
